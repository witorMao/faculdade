<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
	Design by TEMPLATED
	http://templated.co
	Released for free under the Creative Commons Attribution License

	Name       : Untamed 
	Description: A two-column, fixed-width design with dark color scheme.
	Version    : 1.0
	Released   : 20131220
-->
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <!-- Adicionando título da página -->
    <title>OrgCompEDUCA: Início</title>

    <!-- Adicionando uma descrição para a página -->
    <meta
      name="description"
      content="Página web criada para o trabalho final da Disciplina de OrgComp SSC0902 - USP São Carlos, 2019"
    />

    <!-- Adicionando um ícone para a nossa página -->
    <link rel="icon" type="image/png" href="images\save-regular.png" />

    <!-- Adicionando a biblioteca de fonte (Sans Pro) da Google -->
    <link
      href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900"
      rel="stylesheet"
    />

    <!-- Adicionando a folha pessoal de estilos -->
    <link href="default.css" rel="stylesheet" type="text/css" media="all" />

    <!-- Adicionando a folha pessoal de fontes -->
    <link href="fonts.css" rel="stylesheet" type="text/css" media="all" />

    <!-- Font awesome 5 kit (fornece a biblioteca dos ícones utilizados no site) -->
    <script src="https://kit.fontawesome.com/ced1c3619a.js"></script>

    <!-- Script para ativar o uso de tooltips -->
    <script>
      $(document).ready(function() {
        $('[data-toggle="tooltip"]').tooltip();
      });
    </script>
  </head>
  <body>
    <!-- Início da criação do "header" da nossa página -->
    <div id="header-wrapper">
      <div id="header" class="container">
        <div id="logo">
          <h1>
            <i class="far fa-save"></i><a href="index.html"> orgcompeduca</a>
          </h1>
        </div>
        <!-- Seção de design da "barra de nevegação"/ "menu" -->
        <div id="menu">
          <ul>
            <li class="current_page_item">
              <a href="index.html" accesskey="1" title="">Página Inicial</a>
            </li>
            <li><a href="about.html" accesskey="2" title="">Sobre</a></li>
          </ul>
        </div>
      </div>
    </div>
    <!-- Criação do header principal (contido dentro do header maior) -->
    <div id="header-featured">
      <div id="banner-wrapper">
        <div id="banner" class="container" style="margin-top: -8%">
          <h2>BEM-VINDO!</h2>
          <h7 style="text-align: justify">
            Nessa página você irá aprender mais sobre
            <strong>memória cache e suas características!</strong>
          </h7>

          <p style="text-align: center">
            As informações estão dispostas na página como se esta fosse um
            panfleto então, para saber mais sobre o assunto, apenas
            <strong>role a página para baixo</strong> e se divirta aprendendo
            mais sobre a memória cache. Boa leitura!
          </p>
        </div>
      </div>
    </div>

    <!-- Espécie de "sumário" sobre o que oferecemos, com botão que redireciona para cada um -->
    <div id="featured-wrapper">
      <div id="featured" class="extra2 container">
        <!-- Primeiro item: Introdução -->
        <div class="ebox1">
          <span class="fa fa-info"></span>
          <div class="title">
            <h2>1. Introdução</h2>
            <span class="byline"
              >Comece com conhecimentos básicos sobre a memória cache</span
            >
          </div>

          <a href="#introduction" class="button">VAMOS LÁ</a>
        </div>

        <!-- Segundo item: Funções de Mapeamento -->
        <div class="ebox2">
          <span class="fa fa-question"></span>
          <div class="title">
            <h2>2. Funções de Mapeamento</h2>
            <span class="byline">Onde colocar os blocos na cache?</span>
          </div>
          <a href="#mapping" class="button">VAMOS LÁ</a>
        </div>
        <div class="container" style="margin-top: 35vw"></div>

        <!-- Terceiro item: Algoritmos de Substituição -->
        <div class="ebox1">
          <span class="fa fa-info"></span>
          <div class="title">
            <h2>3. Algoritmos de Substituição</h2>
            <span class="byline"
              >Troca de blocos quando a cache está cheia</span
            >
          </div>

          <a href="#algs" class="button">VAMOS LÁ</a>
        </div>

        <!-- Quarto item: Políticas de Escrita -->
        <div class="ebox2">
          <span class="fa fa-question"></span>
          <div class="title">
            <h2>4. Políticas de Escrita</h2>
            <span class="byline"
              >Como lidar com modificações de dados na cache?</span
            >
          </div>
          <a href="#policies" class="button">VAMOS LÁ</a>
        </div>
      </div>
    </div>

    <!-- Seção que cobre a "introdução" ao assunto -->
    <div id="wrapper">
      <div id="introduction"></div>
      <div id="page" class="container">
        <div id="content">
          <!-- título do tema abordado -->
          <div class="title">
            <!-- Descrição rápida do assunto -->
            <h2>INTRODUÇÃO À MEMÓRIA CACHE</h2>
            <span class="byline">Mas afinal, o quê é memória cache?</span>
          </div>

          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Antigamente, o processador trabalhava
            buscando dados e instruções direto na memória principal. Acontece
            que isso era muito ineficiente, visto que o processador tem
            capacidade de trabalhar com mais informações por unidade de tempo do
            que a memória RAM é capaz de fornecer. Pensando em melhorar esse
            ponto é que foi idealizada e criada a memória cache.
          </p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Para conseguir os seus objetivos, ela
            é implementada de forma que fique mais próxima da CPU na placa, mais
            precisamente entre a memória RAM e a CPU, guarde conteúdo nela
            seguindo os princípios de localidade
            <strong
              data-toggle="tooltip"
              data-placement="bottom"
              title="Uma informação próxima de uma outra que acabou de ser consultada também tem grandes chances de ser acessado pelo processador"
              ><i class="fas fa-question-circle"> </i> espacial</strong
            >
            e
            <strong
              data-toggle="tooltip"
              data-placement="bottom"
              title="Um dado que acabou de ser acessado da memória tem grandes chances de ser acessado novamente"
              ><i class="fas fa-question-circle"> </i> temporal</strong
            >, além de seguir o conceito de
            <strong
              data-toggle="tooltip"
              data-placement="bottom"
              title="Um dado é buscado na memória não apenas pelo endereço como na memória principal, mas também pelo seu conteúdo"
              ><i class="fas fa-question-circle"> </i> memória
              associativa</strong
            >. Também além disso, é de tamanho bem pequeno se comparada à
            memória RAM. Resumindo, ela é uma memória de menor capacidade
            afinal, quanto mais endereços na memória, mais tempo para realizar o
            acesso a um dado; está mais perta do processador; as linhas de
            conexão são menores, logo a transmissão de dados leva um tempo
            menor; e que, além disso, guarda dados que há grandes chances de
            serem utilizados durante a execução de um processo. Tudo isso para
            diminuir a quantidade de acessos à memória RAM, que são lentos e,
            assim, otimizar o processador.
          </p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Ainda que a memória cache seja feita e
            implementada dessa forma, se a estratégia para preenchimento dela
            com os dados da memória RAM não for bem selecionada, o desempenho do
            processador pode cair drasticamente, pois os dados que são mantidos
            nela podem não ser os dados necessários para a execução do processo
            no momento atual e isso faz com que o processador seja obrigado a
            buscar o dado na memória RAM de qualquer forma, o que pode levar a
            um desempenho até pior do que quando a cache não está presente, pois
            além da busca na memória principal, o tempo de busca na memória
            cache também é contabilizado.
          </p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Por isso as estratégias para preencher
            a memória cache, mais conhecidas como
            <strong>funções de mapeamento</strong>, devem ser muito bem
            analisadas na hora de implementar a cache. Elas são explicas no
            tópico seguinte e, se você quiser ler sobre elas, basta rolar a
            página para baixo.
          </p>
        </div>
        <div id="sidebar">
          <ul class="style1">
            <img
              src="images/cache.jpg"
              alt="Imagem de uma memória cache"
              height="100%"
              width="100%"
            />Imagem de uma memória cache (sim, ela é pequena). Fonte: techtudo
          </ul>
        </div>
      </div>
    </div>

    <!-- Seção que cobre as "funções de mapeamento" da cache -->
    <div id="wrapper">
      <div id="mapping"></div>
      <div id="page" class="container">
        <div id="content">
          <!-- Título do tema abordado -->
          <div class="title">
            <h2>FUNÇÕES DE MAPEAMENTO</h2>
            <!-- Descrição rápida do tema abordado -->
            <span class="byline"
              >Como mapear um dado da memória princial na memória cache?</span
            >
          </div>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Funções de mapeamento são as
            estratégias para escolha de onde os dados trazidos da memória
            principal serão carregados na memória cache. Elas são extremamente
            necessárias, visto que a memória cache tem capacidade menor do que a
            memória RAM.
          </p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Para o cálculo do endereço da memória
            cache onde os blocos serão colocados, estas funções realizam a
            divisão dos bits do endereço da primeira palavra do bloco na memória
            principal em alguns campos, sendo que o endereço é dividido,
            principalmente, entre
            <i class="fas fa-question-circle"></i>
            <i
              data-toggle="tooltip"
              data-placement="bottom"
              title="Indica a posição de um byte dentro de uma palavra"
              ><b>byte offset</b></i
            >,
            <i class="fas fa-question-circle"></i>
            <i
              data-toggle="tooltip"
              data-placement="bottom"
              title="Indica a posição de uma palavra dentro de um bloco"
              ><b>word offset</b></i
            >
            e
            <i class="fas fa-question-circle"></i>
            <i
              data-toggle="tooltip"
              data-placement="bottom"
              title="Restante dos bits do endereço e que servem para diferenciar qual bloco da memória RAM está na cache visto que vários blocos da RAM podem ser mapeados no mesmo endereço na memória cache"
              ><b>tag</b></i
            >. Podem haver outros campos na divisão, mas estes dependem de qual
            função de mapeamento foi escolhida e serão mostrados em cada uma
            delas.
          </p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Existem três funções de mapeamento,
            sendo elas a de
            <strong>mapeamento direto</strong>,
            <strong>mapeamento associativo total</strong> e
            <strong>mapeamento associativo por conjunto</strong>. Para
            exemplificação das funções de mapeamento a seguir, suponha que
            qualquer endereço da memória principal tenha 8 bits, que a palavra
            utilizada pelo processador seja de 4 bytes, um bloco tenha 2
            palavras e que a memória cache tenha tamanho para 4 blocos.
          </p>

          <!-- Início da abordagem do "Mapeamento Direto" -->
          <p
            style="color: white; font-size: 15px; text-align: justify; background-color: black"
          >
            &nbsp &nbsp &nbsp &nbsp &nbsp <strong>MAPEAMENTO DIRETO</strong>
          </p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Todo bloco da memória principal é
            mapeado em um único endereço para a memória cache. O endereço onde o
            bloco vai ser mapeado na memória cache é dado pela seguinte
            expressão:
          </p>
          <h4>i = j mod b</h4>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbspOnde
            <strong>"i" é o número do bloco da memória cache</strong>,
            <strong>"j" o número do bloco na memória principal</strong> e
            <strong>"b" o número de blocos da memória cache.</strong>
          </p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp A divisão do endereço do bloco na
            memória RAM fica da seguinte forma:
          </p>
          <!-- Imagem da divisão do endereço, seguido de sua legenda -->
          <img src="images/divEnd1.png" height="100%" width="100%" />Ilustração
          da divisão do endereço da memória para o mapeamento direto
          <!-- Uso este paragrafo apenas para dar um espaçamento da imagem para o texto -->
          <p style="margin-bottom: 1vw"></p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Como a palavra só tem 4 bytes, é
            necessário apenas 2 bits para se referir a todos os bytes presentes
            nela. Selecionamos, então, os 2 bits
            <strong>menos significativos</strong> do endereço para serem o
            <i>byte offset</i>. Como o bloco tem 2 palavras, é necessário apenas
            1 bit do endereço para se referir a todas as palavras presentes nele
            e, para isso, pegamos o próximo bit menos significativo que ainda
            não foi utilizado e usamos ele para indicar o <i>word offset</i>.
            Como a operação de mod 4 (quantidade de blocos da cache) dos valores
            do endereço vai dar no máximo 3, os próximos 2 bits do endereço
            serão utilizados para indicar qual o
            <strong>index</strong> (endereço da cache) em que o bloco vai ser
            colocado. O resto dos bits do endereço que não foram utilizados até
            o momento serão reservados para a tag do bloco. Segue exemplo de uma
            simulação do mapeamento de um bloco da memória principal na cache:
          </p>
          <!-- Imagem da simulação, seguida de sua legenda -->
          <img src="images/simDireta.png" height="100%" width="100%" />Mapeamento
          do bloco 2 da memória principal em uma memória cache que utiliza a
          função de mapeamento direto
          <!-- Uso este paragrafo apenas para dar um espaçamento da imagem para o texto -->
          <p style="margin-bottom: 1vw"></p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Esse tipo de mapeamento tem vantagens
            o baixo custo e simplicidade na implementação e como desvantagens
            tem o fato de que como cada bloco só pode ser mapeado em uma única
            posição na cache, caso blocos distintos acabem tendo de ser levados
            à memória cache e sejam mapeados na mesma posição, leva à realização
            de várias trocas naquela posição o que acaba levando a baixa
            <i class="fas fa-question-circle"></i
            ><strong
              data-toggle="tooltip"
              data-placement="bottom"
              title="Fração dos acessos à memória que foram encontrados na cache"
            >
              taxa de acerto</strong
            >, logo a um baixo desempenho do processador.
          </p>
          <!-- Início da abordagem do "Mapeamento Associativo Total" -->
          <p
            style="color: white; font-size: 15px; text-align: justify; background-color: black"
          >
            &nbsp &nbsp &nbsp &nbsp &nbsp
            <strong>MAPEAMENTO ASSOCIATIVO TOTAL</strong>
          </p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Nesse mapeamento, todo bloco da
            memória principal pode ser mapeado em qualquer endereço de bloco na
            memória cache.
          </p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp A divisão do endereço do bloco na
            memória RAM fica da seguinte forma:
          </p>
          <!-- Imagem da divisão do endereço, seguida de sua legenda -->
          <img src="images/divEnd3.png" height="100%" width="100%" />Ilustração
          da divisão do endereço da memória para o mapeamento associativo total

          <!-- Uso este paragrafo apenas para dar um espaçamento da imagem para o texto -->
          <p style="margin-bottom: 1vw"></p>
          <!-- Início da abordagem do "Mapeamento Associativo por Conjuntos" -->
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Como a palavra só tem 4 bytes é
            necessário apenas 2 bits para se referir a todos os bytes presentes
            nela, então selecionamos os 2 bits menos significativos do endereço
            para serem o byte offset. Como o bloco tem 2 palavras é necessário
            apenas 1 bit do endereço para se referir a todas as palavras
            presentes nele, para isso pegamos o próximo bit menos significativo
            que ainda não foi utilizado, e usamos ele para indicar o word
            offset. O resto dos bits do endereço que não foram utilizados até o
            momento serão a tag do bloco. Segue exemplo de uma simulação do
            mapeamento de um bloco da memória principal na cache:
          </p>
          <!-- Simulação do mapeamento associativo total, seguida de sua legenda -->
          <img src="images/simTotal.png" height="100%" width="100%" />Mapeamento
          do bloco 2 da memória principal em uma memória cache que utiliza a
          função de mapeamento total
          <!-- Uso este paragrafo apenas para dar um espaçamento da imagem para o texto -->
          <p style="margin-bottom: 1vw"></p>

          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Esse tipo de mapeamento tem vantagem o
            fato de não trazer um bloco diferentes da memória RAM para o mesmo
            lugar na memŕoia cache diminuindo assim o número de trocas a serem
            feitas na cache e como desvantagens tem o fato de que o circuito
            para a verificação se um bloco está ou não na cache é bem complexo,
            pois compara todas as tags presentes na cache simultaneamente com a
            tag do bloco buscado buscado.
          </p>
          <!-- Início da abordagem do mapeamento associativo por conjuntos -->
          <p
            style="color: white; font-size: 15px; text-align: justify; background-color: black"
          >
            &nbsp &nbsp &nbsp &nbsp &nbsp
            <strong>MAPEAMENTO ASSOCIATIVO POR CONJUNTOS</strong>
          </p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Nesse mapeamento a memória cache é
            dividida em n conjuntos com k blocos cada. E o bloco da memória
            principal é colocado em um dos conjuntos da cache da mesma forma que
            no mapeamento direto, ou seja, ele sempre é colocado no mesmo
            conjunto da memória cache, entretanto o bloco do conjunto onde ele é
            colocado pode mudar, pois segue a mesma ideia do método associativo
            total. Para o exemplo a seguir, considere uma cache com 2 conjuntos
            e cada conjunto contendo 2 blocos.
          </p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp A divisão do endereço do bloco na
            memória RAM fica da seguinte forma:
          </p>

          <!-- Imagem da divisão do endereço, seguida de sua legenda -->
          <img src="images/divEnd2.png" height="100%" width="100%" />Mapeamento
          do bloco 2 da memória principal em uma memória cache que utiliza a
          função de mapeamento total

          <!-- Uso este paragrafo apenas para dar um espaçamento da imagem para o texto -->
          <p style="margin-bottom: 1vw"></p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Como a palavra só tem 4 bytes é
            necessário apenas 2 bits para se referir a todos os bytes presentes
            nela, então selecionamos os 2 bits menos significativos do endereço
            para serem o byte offset. Como o bloco tem 2 palavras é necessário
            apenas 1 bit do endereço para se referir a todas as palavras
            presentes nele, para isso pegamos o próximo bit menos significativo
            que ainda não foi utilizado, e usamos ele para indicar o word
            offset. Como essa cache só possui 2 conjuntos é necessário apenas 1
            bit para se referir a qualquer um deles, então pega-se o próximo bit
            não utilizado para representar o set (conjunto da cache). O resto
            dos bits do endereço que não foram utilizados até o momento serão a
            tag do bloco. Segue exemplo de uma simulação do mapeamento de um
            bloco da memória principal na cache.
          </p>
          <!-- Simulação do mapeamento associativo por conjuntos, seguida de sua legenda -->
          <img src="images/simAssociativa.png" height="100%" width="100%" />Mapeamento
          do bloco 2 da memória principal em uma memória cache que utiliza a
          função de mapeamento total:

          <!-- Uso este paragrafo apenas para dar um espaçamento da imagem para o texto -->
          <p style="margin-bottom: 1vw"></p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Esse tipo de mapeamento combina
            vantagens das duas funções de mapeamento vistas anteriormente e como
            desvantagens tem o fato de que o circuito para a verificação se um
            bloco está ou não na cache é mais simples que o circuito utilizado
            para a mesma finalidade no mapeamento associativo total, mas ainda
            continua sendo complexo, pois compara todas as tags presentes em um
            conjunto da cache simultaneamente com a tag do bloco buscado.
          </p>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Como o mapeamento associativo por
            conjunto pode-se implementar os outros dois tipos de mapeamento.
            Para implementar o direto com ele o número de conjuntos deve ser
            igual ao número de blocos que a memória cache suporta e cada
            conjunto deve ter apenas um bloco. Já para implementar o mapeamento
            associativo total é necessário que o haja apenas um conjunto e que
            ele contenha todos os blocos suportados pela cache.
          </p>
        </div>
        <div id="sidebar">
          <img src="images/blackboard.png" height="100%" width="100%" />
        </div>
      </div>
    </div>

    <!-- Seção que cobre os "algoritmos de substituição" da cache -->
    <div id="wrapper">
      <div id="algs"></div>
      <div id="page" class="container">
        <div id="content">
          <!-- Título do tema abordado -->
          <div class="title">
            <h2>ALGORITMOS DE SUBSTITUIÇÃO</h2>
            <!-- Descrição rápida do tema abordado -->
            <span class="byline"
              >Entenda os possíveis procedimentos para quando a cache estiver
              cheia</span
            >
          </div>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbspQuando um bloco deve ser colocado na
            cache existe a possibilidade de não haver espaço livre na cache ou
            de a posição já estar ocupada por outro bloco e isso leva à
            necessidade da implementação de algoritmos para a substituição dos
            blocos na cache. No caso do <strong>mapeamento direto</strong>, como
            os blocos são sempre levados à uma posição única na cache, não há a
            necessidade da implementação de algoritmos de substituição, pois
            quando a posição para onde o bloco foi mapeado estiver ocupada ele
            vai sobrescrever os dados que estiverem lá. Já nos casos de
            <strong>mapeamento associativo total</strong> e
            <strong>por conjunto</strong>, faz-se necessária a implementação de
            algoritmos para a escolha de qual bloco da cache deve ser
            substituído. São eles:
          </p>
          <ul class="style2" style="margin-left: 2vw">
            <li style="text-align: left">
              <strong>FIFO (First In, First Out):</strong>
            </li>
            <p style="font-size: 15px; text-align: justify">
              Esse algoritmo retira o bloco que está a mais tempo na cache. Para
              a implementação dele é necessário que seja reservado um espaço em
              cada posição da cache para guardar o valor de um contador, além
              disso deve ser utilizado um contador. Sempre que um bloco é
              adicionado na cache, no lugar reservado para o valor do contador
              onde o bloco vai ser adicionado é guardado o valor atual do
              contador e o contador incrementado. Na quando for necessária a
              substituição, os valores dos contadores de cada bloco da cache são
              verificados e o bloco que tiver o menor és sobrescrito pelo novo
              bloco;
            </p>
            <li style="text-align: left">
              <strong>LRU (Least Recently Used):</strong>
            </li>
            <p style="font-size: 15px; text-align: justify">
              Bloco a ser retirado é o que não é referenciado há mais tempo.
              Para implementação dele é necessário a reserva de um espaço para o
              valor de um contador e para cada posição da cache é associado um
              contador. Quando o bloco é referenciado e ocorre um acerto, o
              contador referente a ele recebe 0, enquanto todos os outros são
              incrementados. Quando é necessária a substituição de um dos blocos
              da cache os valores referentes aos contadores de cada bloco são
              verificados e o bloco que possui o maior valor é substituído.
            </p>
            <li style="text-align: left">
              <strong>LFU(Least Frequently Used):</strong>
            </li>
            <p style="font-size: 15px; text-align: justify">
              Bloco a ser substituído é o que tiver a menor frequência de uso
              (n°de acessos do bloco/n° de acessos totais a cache). Para
              implementação dele é necessário a reserva de um espaço para o
              valor de um contador e para cada posição da cache é associado um
              contador, além disso deve-se ter também um contador para o total
              de acessos realizados a cache. Quando a substituição de um bloco
              for necessária deve-se fazer calcular a frequência de acesso a
              cada bloco substituir aquele que tiver o menor valor.
            </p>
            <li style="text-align: left">
              <strong>Aleatório:</strong>
            </li>
            <p style="font-size: 15px; text-align: justify">
              O bloco a ser substituído é escolhido ao acaso. Para a
              implementação desse algoritmo deve-se utilizar um contador que é
              incrementado junto com o clock do computador e quando for
              necessária a substituição de um dos blocos, o bloco escolhido é o
              que tiver o endereço igual ao valor do contador.
            </p>
          </ul>
        </div>
      </div>
    </div>

    <!-- Seção que cobre as "políticas de escrita" da cache -->
    <div id="wrapper">
      <div id="policies"></div>
      <div id="page" class="container">
        <div id="content">
          <!-- Título do tema abordado -->
          <div class="title">
            <h2>POLÍTICAS DE ESCRITA</h2>
            <!-- Descrição rápida do tema abordado -->
            <span class="byline"
              >Leitura é fácil mas o quê será que acontece quando precisamos
              escrever dados?</span
            >
          </div>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Quando se lida com a escrita de dados
            e a arquitetura é i mplementada com uma memória cache nos deparamos
            com um problema: quando o dado modificado deve ser escrito na
            memória principal? Afinal de contas outros componentes da
            arquitetura (como os módulos de entrada e saída) podem necessitar do
            dado que acabou de ser modificado em cache e caso o dado não esteja
            atualizado na memória RAM pode ocasionar problemas na execução dos
            seus processos. Para resolução desse problema temos que levar em
            consideração algumas situações explicitadas a seguir:
          </p>
          <ul class="style2" style="margin-left: 2vw">
            <li style="text-align: left">
              <strong>Dado a ser modificado está em cache (write hit):</strong>
            </li>
            <p style="font-size: 15px; text-align: justify">
              Quando há o write hit temos duas possibilidades modificar o dado
              apenas em cache (write back) e quando o bloco for substituído
              modificar a memória principal ou modificar em cache e em RAM
              (write through).
            </p>
            <ul class="style2" style="margin-left: 2vw">
              <p style="font-size: 15px; text-align: justify">
                <strong>Write back</strong>: para a implementação dessa política
                deve ser adicionado espaço para um bit de modificação para cada
                bloco da memória cache, sendo que quando houver uma escrita
                nesse bloco, o bit modificado é setado e quando este bloco tiver
                de ser substituído por outro vindo da memória principal, o bit
                modificado é verificado e caso esteja setado o bloco é escrito
                na memória RAM.
              </p>
              <p style="font-size: 15px; text-align: justify">
                <strong>Write through</strong>: para a implementação dessa
                política de escrita, assim que o bloco for modificado na memória
                cache ele é escrito imediatamente no nível inferior.
              </p>
            </ul>
            <li style="text-align: left">
              <strong
                >Dado a ser modificado não está em cache (write miss):</strong
              >
            </li>
            <p style="font-size: 15px; text-align: justify">
              Quando há o write miss temos duas possibilidades trazer o bloco
              para a cache e modificá-lo (write allocate) ou modificar o bloco
              diretamente na memória principal (write no allocate).
            </p>
            <ul class="style2" style="margin-left: 2vw">
              <p style="font-size: 15px; text-align: justify">
                <strong>Write allocate</strong>: para a implementação dessa
                política, é necessário que o bloco na cache tenha espaço para o
                bit modificado assim como na write back e assim que o bloco não
                for encontrado na cache ele é buscado nos níveis inferiores até
                ser encontrado. Quando for encontrado, é trazido para o maior
                nível da cache e modificado lá.
              </p>
              <p style="font-size: 15px; text-align: justify">
                <strong>Write no-allocate</strong>: para a implementação dessa
                política de escrita, quando o bloco não é encontrado no nível
                superior da memória cache, ele é buscado diretamente na memória
                RAM e modificado lá.
              </p>
            </ul>

            <p style="font-size: 15px; text-align: justify">
              Na implementação real da memória cache, são combinadas duas da
              políticas de escrita uma para write hit e outra para write miss.
              As combinações possíveis são:
            </p>
            <ul class="style2" style="margin-left: 2vw">
              <p style="font-size: 15px; text-align: justify">
                <strong>Write back e write allocate</strong>: Estas devem ser
                implementadas juntas, pois as duas utilizam o bit de
                modificação. As operações de leitura e escrita ficam como
                explicadas no fluxograma a seguir:
              </p>
              <!-- Fluxograma 1-->
              <img
                src="images/WBack & WAllocate.png"
                height="100%"
                width="100%"
              />Sequencia de passos para a execução do Write Back e Write
              Allocate

              <!-- Uso este paragrafo apenas para dar um espaçamento da imagem para o texto -->
              <p style="margin-bottom: 1vw"></p>
              <p style="font-size: 15px; text-align: justify">
                <strong>Write through e write no allocate</strong>: as operações
                de leitura e escrita ficam como explicadas no fluxograma a
                seguir:
              </p>

              <!-- Fluxograma 2 -->
              <img
                src="images/Wthrough & WnoAloccate.png"
                height="100%"
                width="100%"
              />Sequencia de passos para a execução do Write Through e Write
              No-Allocate

              <!-- Uso este paragrafo apenas para dar um espaçamento da imagem para o texto -->
              <p style="margin-bottom: 1vw"></p>
            </ul>
          </ul>
        </div>
        <div id="sidebar">
          <img src="images/blackboard2.png" height="100%" width="100%" />
        </div>
      </div>
    </div>

    <!-- Seção que cobre os "algoritmos de substituição" da cache -->
    <div id="wrapper">
      <div id="ending"></div>
      <div id="page" class="container">
        <div id="content">
          <!-- Título do tema abordado -->
          <div class="title">
            <h2>FINALIZANDO</h2>
            <!-- Descrição rápida do tema abordado -->
            <span class="byline">Ta quase la......</span>
          </div>
          <p style="font-size: 15px; text-align: justify">
            &nbsp &nbsp &nbsp &nbsp &nbsp Se você chegou até aqui, pôde entender
            que a memória cache é uma memória de menor capacidade e é
            implementada de forma a tentar diminuir a quantidade de acessos à
            memória RAM, já que eles são muito lentos. Pôde compreender, também,
            que existem funções de mapeamento para escolher onde os blocos da
            memória RAM devem ser colocados na memória cache e que elas
            desempenham um papel crucial no desempenho da cache. Além disso, viu
            que a cache possui um tamanho menor que o da memória RAM e, por
            isso, ela pode ser preenchida totalmente e depois ser necessário que
            outro dado seja colocado nela e, para isso, devemos utilizar os
            algoritmos de substituição. Viu, também, que o dado pode acabar
            sendo modificado na cache mas não na memória RAM e outro componente
            da arquitetura necessitar desse dado atualizado, sendo que, para
            resolver estes problemas, sincronizamos os dados da cache com os da
            RAM utilizando as políticas de escrita.
          </p>
          <br/>
          <br/>
        </div>
      </div>
    </div>

    <!-- Footer da nossa página -->
    <div id="copyright" class="container">
      <p>
        &copy; 2019 SSC0902 | Design inspired by
        <a href="http://templated.co" rel="nofollow">TEMPLATED</a>.
      </p>
    </div>
  </body>
</html>
